<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pexels Image Fetcher - Unique Grid View with Download</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for the active tab */
        .tab-button.active {
            border-bottom: 3px solid #3b82f6;
            color: #1f2937;
            font-weight: 600;
        }
        
        /* Image grid styling */
        #image-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1rem;
        }
        
        .grid-image-wrapper {
            position: relative;
            padding-top: 56.25%; /* 16:9 Aspect Ratio */
            overflow: hidden;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .grid-image {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            transition: transform 0.3s ease-in-out;
        }
        
        .grid-image:hover {
            transform: scale(1.05);
        }

        /* Download Button Styling */
        .download-button {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            background-color: rgba(59, 130, 246, 0.8); /* Blue with transparency */
            color: white;
            padding: 0.25rem 0.5rem;
            border-radius: 0.375rem;
            font-size: 0.75rem;
            font-weight: 600;
            opacity: 0;
            transition: opacity 0.3s, background-color 0.2s;
            z-index: 10;
        }

        .grid-image-wrapper:hover .download-button {
            opacity: 1;
        }

        .download-button:hover {
            background-color: #2563eb;
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen p-4 flex flex-col items-center font-sans">

    <div class="w-full max-w-4xl text-center mb-6">
        <h1 class="text-3xl font-extrabold text-gray-800 mb-2">Pexels Spiritual Image Grid</h1>
        <p class="text-gray-600">Always showing new, unique images. All images link to 1920x1080 resolution for download.</p>
    </div>

    <div class="w-full max-w-md bg-white rounded-t-xl shadow-lg">
        <div class="flex border-b border-gray-200">
            <button id="tab-fetch-btn" class="tab-button active flex-1 py-3 text-gray-800">
                Fetch New Data
            </button>
        </div>

        <div id="tab-fetch" class="p-6">
            <form id="fetch-form" class="flex flex-col space-y-4">
                
                <div>
                    <label for="api-key-input" class="block text-sm font-medium text-gray-700 mb-1">
                        Pexels API Key
                    </label>
                    <input type="password" id="api-key-input" placeholder="Paste your Pexels Key here" 
                           class="w-full p-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500"
                           oninput="saveApiKey()">
                    <p class="text-xs text-gray-500 mt-1">Key is saved locally in your browser and is not stored externally.</p>
                </div>
                
                <div class="flex flex-col sm:flex-row sm:space-x-4 space-y-4 sm:space-y-0">
                    
                    <div class="flex-1">
                        <label for="category" class="block text-sm font-medium text-gray-700 mb-1">Image Category</label>
                        <select id="category" name="category" class="w-full p-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500">
                            <option value="Islamic spiritual atmosphere, deep sense of peace and submission, awareness of Allah’s presence, Allah’s creation, vast natural scenery, flowing rivers symbolizing life, green fields and hills, high mountains showing Allah’s greatness, forests filled with light and shadow, ocean waves reflecting divine power, calm lakes and reflections, sunrise bringing hope, sunset reminding of ending, clouds moving across the sky, rain as mercy from Allah, rainbow as a sign of hope, star-filled sky inspiring reflection, moonlight night creating tranquility, real mosque exterior in harmony with nature, mosque interior filled with calmness, silent prayer space, minarets calling hearts toward Allah, domes symbolizing unity, Islamic architectural beauty, Quran as guidance, open Quran with peaceful light, Quran resting with respect, tasbih as remembrance of Allah, prayer mat symbolizing humility, hands raised in sincere dua, moments of sujood, human reflection without identity, silhouette of a believer in prayer, back view of a servant turning to Allah, individual sitting alone in deep thought, tafakkur on creation, fajr atmosphere full of purity, night prayer filled with silence, Ramadan spirit, iftar time after patience, patience and sabr, gratitude and shukr, repentance and tawbah, mercy and forgiveness, remembrance of Akhirah, calm graveyard reminder, journey of life symbolized by empty road, desert symbolizing trials, abandoned places reminding worldly temporary nature, cycle of life and death, hope after hardship, light after darkness, greenery after rain, feeling of guidance, trust in Allah, complete reliance on Allah">All Spiritual & Reflective Themes</option>
                            <option value="vast natural scenery, high mountains, flowing rivers, ocean waves">Nature & Divine Greatness</option>
                            <option value="real mosque exterior in harmony with nature, mosque interior filled with calmness, minarets, domes, Islamic architectural beauty">Mosque & Architecture</option>
                            <option value="silhouette of a believer in prayer, moments of sujood, hands raised in sincere dua, fajr atmosphere, night prayer">Worship & Prayer Moments</option>
                            <option value="Quran as guidance, open Quran with peaceful light, tasbih as remembrance of Allah, prayer mat">Objects of Remembrance</option>
                            <option value="desert symbolizing trials, abandoned places reminding worldly temporary nature, calm graveyard reminder, cycle of life and death, hope after hardship">Trials & Akhirah Reflection</option>
                        </select>
                    </div>
                    
                    <div class="flex-1">
                        <label for="per_page" class="block text-sm font-medium text-gray-700 mb-1">Number of Images (Max 100)</label>
                        <input type="number" id="per_page" name="per_page" min="1" max="100" value="15" required class="w-full p-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500">
                    </div>
                </div>

                <button type="submit" class="w-full py-2 px-4 bg-blue-600 text-white font-semibold rounded-lg shadow-md hover:bg-blue-700 transition duration-200">
                    New Request
                </button>
            </form>
        </div>
    </div>

    <div id="status-message" class="mt-4 p-4 rounded-lg text-lg font-medium w-full max-w-4xl text-center">
        </div>

    <div id="image-grid-container" class="w-full max-w-4xl mt-6 p-4 bg-white rounded-xl shadow-lg">
        <h2 class="text-2xl font-bold text-gray-800 mb-4 border-b pb-2">Fetched Images</h2>
        <div id="image-grid">
            <p class="text-gray-500 italic p-4 text-center">Enter your API key and click 'New Request' to fetch unique images.</p>
        </div>
    </div>


    <script>
        // --- Configuration Constants ---
        const API_KEY_STORAGE_KEY = "pexels_api_key";
        const VIEWED_IDS_KEY_PREFIX = "pexels_viewed_ids_"; 
        const API_BASE_URL = "https://api.pexels.com/v1/search";
        const CACHE_KEY_PREFIX = "pexels_photo_cache_";
        const HISTORY_KEY = "pexels_slideshow_history";
        const CACHE_DURATION_MS = 3600000; // 1 hour
        
        // --- DOM Elements ---
        const form = document.getElementById('fetch-form');
        const apiKeyInput = document.getElementById('api-key-input'); 
        const categorySelect = document.getElementById('category');
        const perPageInput = document.getElementById('per_page');
        const statusMessage = document.getElementById('status-message');
        const imageGrid = document.getElementById('image-grid');

        // --- State ---
        // Get all possible values for randomization from the <select> options
        const AVAILABLE_CATEGORIES = Array.from(categorySelect.options).map(option => option.value);

        /**
         * Selects a random category value from the AVAILABLE_CATEGORIES list and sets it as active.
         */
        function randomizeCategory() {
            const randomIndex = Math.floor(Math.random() * AVAILABLE_CATEGORIES.length);
            categorySelect.value = AVAILABLE_CATEGORIES[randomIndex];
        }


        /**
         * Loads and returns the set of photo IDs already viewed for a specific query.
         */
        function loadViewedIds(query) {
            // Use the full query string as the unique key for viewed IDs
            const key = VIEWED_IDS_KEY_PREFIX + query; 
            try {
                const stored = localStorage.getItem(key);
                return stored ? new Set(JSON.parse(stored)) : new Set();
            } catch (e) {
                console.error("Error loading viewed IDs:", e);
                return new Set();
            }
        }

        /**
         * Saves a set of new photo IDs to the permanent viewed list for a specific query.
         */
        function saveViewedIds(query, newIds) {
            const key = VIEWED_IDS_KEY_PREFIX + query;
            try {
                const existingIds = loadViewedIds(query);
                for (const id of newIds) {
                    existingIds.add(id);
                }
                localStorage.setItem(key, JSON.stringify(Array.from(existingIds)));
            } catch (e) {
                console.error("Error saving viewed IDs:", e);
            }
        }


        /**
         * Clears the current image grid and populates it with new images, including the download button.
         * @param {Array<Object>} photos - Array of Pexels photo objects.
         * @param {string} query - The search query/category.
         */
        function renderImageGrid(photos, query) {
            imageGrid.innerHTML = '';
            
            if (photos.length === 0) {
                imageGrid.innerHTML = `<p class="text-gray-500 italic p-4 text-center">No new unique images found for '${query}'. Try another theme.</p>`;
                return;
            }

            const newIds = new Set();
            photos.forEach((photo, index) => {
                newIds.add(photo.id); 

                const wrapper = document.createElement('div');
                wrapper.className = 'grid-image-wrapper';

                // Image element
                const img = document.createElement('img');
                // Use 'large2x' for efficient grid preview (1200px wide)
                img.src = photo.src.original.replace('original', 'large2x'); 
                img.alt = `${query} image ${index + 1}`;
                img.className = 'grid-image';
                img.loading = 'lazy'; 

                // Download Button (Points to the original/highest resolution source)
                const downloadLink = document.createElement('a');
                // The 'original' size generally guarantees the highest quality, suitable for 1920x1080.
                downloadLink.href = photo.src.original; 
                downloadLink.download = `Pexels_Spiritual_Photo_${photo.id}.jpg`;
                downloadLink.target = '_blank';
                downloadLink.className = 'download-button';
                downloadLink.textContent = 'Download (1920x1080+)';

                wrapper.appendChild(img);
                wrapper.appendChild(downloadLink);
                imageGrid.appendChild(wrapper);
            });

            // Persist the IDs of the newly displayed images
            saveViewedIds(query, newIds);

            displayStatus(`Successfully loaded ${photos.length} new unique images for theme.`, 'success');
        }

        // --- API Key Management (Unchanged) ---
        
        function getApiKey() {
            return apiKeyInput.value.trim();
        }

        function saveApiKey() {
            try {
                localStorage.setItem(API_KEY_STORAGE_KEY, apiKeyInput.value.trim());
            } catch (error) {
                console.error("Failed to save API key to local storage:", error);
            }
        }

        function loadApiKey() {
            try {
                const storedKey = localStorage.getItem(API_KEY_STORAGE_KEY);
                if (storedKey) {
                    apiKeyInput.value = storedKey;
                    displayStatus("API Key loaded from local storage. Ready for a New Request.", 'info');
                } else {
                    displayStatus("Please enter your Pexels API Key above to fetch images.", 'error');
                }
            } catch (error) {
                console.error("Failed to load API key from local storage:", error);
                displayStatus("Error accessing local storage for API Key. Please enter it manually.", 'error');
            }
        }

        // --- Status Display (Simplified) ---

        function displayStatus(message, type = 'loading') {
            statusMessage.textContent = message;
            statusMessage.className = 'mt-4 p-4 rounded-lg text-lg font-medium w-full max-w-4xl text-center transition-colors';
            
            if (type === 'error') {
                statusMessage.classList.add('bg-red-200', 'text-red-800');
            } else if (type === 'success') {
                statusMessage.classList.add('bg-green-200', 'text-green-800');
            } else if (type === 'info') {
                statusMessage.classList.add('bg-yellow-200', 'text-yellow-800');
            } else {
                statusMessage.classList.add('bg-blue-200', 'text-blue-800');
            }
        }
        
        /**
         * Core fetching logic with built-in loop to find unique images.
         */
        async function fetchPexelsImage(query, perPage) {
            const apiKey = getApiKey();
            
            if (!apiKey) {
                displayStatus("CRITICAL: Please enter your Pexels API Key above to fetch images.", 'error');
                return;
            }

            let uniquePhotos = [];
            const viewedIds = loadViewedIds(query);
            let page = 1;
            const MAX_PAGES = 10; 
            const FETCH_BATCH_SIZE = 80; // Fetch max possible to increase chance of finding unique photos

            displayStatus(`Searching for ${perPage} new unique images for the selected theme (Page ${page})...`);
            
            while (uniquePhotos.length < perPage && page <= MAX_PAGES) {
                // To maximize diversity given the long query string, we set orientation=landscape.
                const PEXELS_SEARCH_URL = `${API_BASE_URL}?query=${encodeURIComponent(query)}&per_page=${FETCH_BATCH_SIZE}&orientation=landscape&page=${page}`;
                
                try {
                    const response = await fetch(PEXELS_SEARCH_URL, {
                        method: 'GET',
                        headers: { 'Authorization': apiKey, 'Content-Type': 'application/json' }
                    });

                    if (!response.ok) {
                        throw new Error(`Failed to fetch data: HTTP status ${response.status}`);
                    }

                    const data = await response.json();
                    
                    if (!data.photos || data.photos.length === 0) {
                        displayStatus(`Search finished. Found ${uniquePhotos.length} unique images. No more photos available for this theme.`, 'info');
                        break;
                    }

                    const newlyFetchedPhotos = data.photos;
                    
                    // Filter out already viewed photos and duplicates
                    const newUniqueBatch = newlyFetchedPhotos.filter(photo => {
                        return !viewedIds.has(photo.id) && !uniquePhotos.some(p => p.id === photo.id);
                    });

                    // Add new unique photos to the result array, capping at the requested amount
                    uniquePhotos.push(...newUniqueBatch.slice(0, perPage - uniquePhotos.length));
                    
                    if (data.next_page) {
                        page++;
                        if (uniquePhotos.length < perPage) {
                            displayStatus(`Searching for ${perPage - uniquePhotos.length} more unique images for theme (Page ${page})...`);
                        }
                    } else {
                        break; 
                    }

                } catch (error) {
                    console.error("Fetch Error:", error);
                    displayStatus(`Error fetching images: ${error.message}`, 'error');
                    renderImageGrid([], query);
                    return;
                }
            } 

            if (uniquePhotos.length > 0) {
                // Skip history/cache logic for simplicity but maintain viewed IDs
                renderImageGrid(uniquePhotos, query);
            } else {
                 displayStatus(`Found 0 new unique images for the selected theme. All photos for this term might have been viewed.`, 'info');
                 renderImageGrid([], query); 
            }
        }

        // --- Event Listeners and Initialization ---
        form.addEventListener('submit', function(event) {
            event.preventDefault();
            
            // Randomize category FIRST
            randomizeCategory();

            // Get query after randomization
            const query = categorySelect.value; 
            const perPage = Math.min(100, Math.max(1, parseInt(perPageInput.value) || 15)); 
            perPageInput.value = perPage;

            // Fetch new unique images
            fetchPexelsImage(query, perPage); 
        });

        window.onload = () => {
            loadApiKey();
            
            // Initial check to ensure a category is selected and provide instructions
            if (categorySelect.value) {
                displayStatus("Ready to search. Click 'New Request' to fetch unique images.", 'info');
            }
        };
    </script>
</body>
</html>
