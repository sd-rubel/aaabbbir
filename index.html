<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic Pexels Slideshow - Video Recorder</title>
    <!-- Load Tailwind CSS for modern, responsive styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for the canvas container to maintain 16:9 aspect ratio */
        #canvas-container {
            width: 100%;
            max-width: 900px; 
            margin: 0 auto;
            /* The padding-top trick maintains the aspect ratio: (9 / 16) * 100 = 56.25% */
            padding-top: 56.25%; 
            position: relative;
            background-color: #1f2937; /* Dark background */
            border-radius: 0.75rem;
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.2);
            overflow: hidden;
            transition: max-width 0.3s, padding-top 0.3s;
        }

        /* Fullscreen styles for the container */
        #canvas-container:fullscreen {
            max-width: none;
            width: 100%;
            height: 100vh;
            padding-top: 0;
            border-radius: 0;
            box-shadow: none;
        }

        /* Canvas inside container */
        #photo-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: block;
        }

        /* Fullscreen styles for the canvas element itself */
        #photo-canvas:fullscreen {
            width: 100%;
            height: 100%;
        }

        /* Style for the active tab */
        .tab-button.active {
            border-bottom: 3px solid #3b82f6;
            color: #1f2937;
            font-weight: 600;
        }
        
        /* Style for history items */
        .history-item {
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .history-item:hover {
            background-color: #f3f4f6;
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen p-4 flex flex-col items-center font-sans">

    <div class="w-full max-w-4xl text-center mb-6">
        <h1 class="text-3xl font-extrabold text-gray-800 mb-2">Pexels Slideshow</h1>
        <p class="text-gray-600">Pan/Zoom effect with cross-fade transition.</p>
    </div>

    <!-- Tabs Container -->
    <div class="w-full max-w-md bg-white rounded-t-xl shadow-lg">
        <div class="flex border-b border-gray-200">
            <button id="tab-fetch-btn" onclick="switchTab('fetch')" class="tab-button active flex-1 py-3 text-gray-500 hover:text-gray-800 transition duration-150">
                Fetch New Data
            </button>
            <button id="tab-history-btn" onclick="switchTab('history')" class="tab-button flex-1 py-3 text-gray-500 hover:text-gray-800 transition duration-150">
                Load from History
            </button>
        </div>

        <!-- Tab Content: Fetch New Data -->
        <div id="tab-fetch" class="p-6">
            <form id="fetch-form" class="flex flex-col space-y-4">
                <!-- Duration Slider -->
                <div>
                    <label for="pan-duration" class="block text-sm font-medium text-gray-700 mb-1">
                        Pan/Transition Duration: <span id="duration-display">4.0</span> seconds
                    </label>
                    <input type="range" id="pan-duration" min="2000" max="10000" step="500" value="4000" 
                           class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer range-lg" 
                           oninput="updateDurationDisplay(this.value)">
                </div>

                <div class="flex flex-col sm:flex-row sm:space-x-4 space-y-4 sm:space-y-0">
                    <!-- Category Dropdown -->
                    <div class="flex-1">
                        <label for="category" class="block text-sm font-medium text-gray-700 mb-1">Image Category</label>
                        <select id="category" name="category" class="w-full p-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500">
                            <option value="nature">Nature</option>
                            <option value="islamic">Muslim and Islamic Related</option>
                            <option value="flower">Flowers</option>
                            <option value="city">City / Architecture</option>
                            <option value="technology">Technology</option>
                            <option value="travel">Travel</option>
                            <option value="food">Food</option>
                            <option value="abstract">Abstract</option>
                        </select>
                    </div>
                    
                    <!-- Number of Images Input -->
                    <div class="flex-1">
                        <label for="per_page" class="block text-sm font-medium text-gray-700 mb-1">Number of Images (Max 100)</label>
                        <input type="number" id="per_page" name="per_page" min="1" max="100" value="15" required class="w-full p-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500">
                    </div>
                </div>

                <!-- Submit Button -->
                <button type="submit" class="w-full py-2 px-4 bg-blue-600 text-white font-semibold rounded-lg shadow-md hover:bg-blue-700 transition duration-200">
                    Fetch & Start Slideshow
                </button>
            </form>
        </div>

        <!-- Tab Content: History -->
        <div id="tab-history" class="p-6 hidden">
            <h3 class="text-xl font-semibold text-gray-800 mb-4 border-b pb-2">Cached Searches</h3>
            <ul id="history-list" class="space-y-2 max-h-64 overflow-y-auto">
                <li class="text-gray-500 italic">No previous searches found.</li>
            </ul>
        </div>
    </div>

    <!-- Status/Error Message Area -->
    <div id="status-message" class="mt-4 p-4 rounded-lg text-lg font-medium w-full max-w-4xl text-center">
        <!-- Messages will be inserted here -->
    </div>

    <!-- Canvas Container (16:9 aspect ratio maintained by CSS) -->
    <div id="canvas-container" class="mb-4">
        <canvas id="photo-canvas">
            Your browser does not support the HTML canvas tag.
        </canvas>
    </div>

    <!-- Controls Container (Fullscreen, Record) -->
    <div class="flex flex-col items-center w-full max-w-lg mb-8 space-y-4">
        
        <!-- Recording Duration Input -->
        <div class="w-full flex justify-center items-center space-x-2 bg-white p-3 rounded-lg shadow">
            <label for="record-duration-min" class="text-sm font-medium text-gray-700 whitespace-nowrap">
                Record For:
            </label>
            <input type="number" id="record-duration-min" min="1" max="10" value="5" required 
                   oninput="updateRecordDurationDisplay()"
                   class="w-16 p-2 border border-gray-300 rounded-md text-center focus:ring-red-500 focus:border-red-500">
            <span class="text-sm font-medium text-gray-700">minutes</span>
        </div>

        <div class="flex justify-center space-x-4">
            <!-- Fullscreen Button -->
            <button id="fullscreen-btn" onclick="toggleFullscreen()" class="p-3 bg-gray-500 text-white rounded-full shadow-lg hover:bg-gray-600 transition duration-200" title="Toggle Fullscreen">
                <!-- SVG for Fullscreen Icon -->
                <svg id="fullscreen-icon" class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8V4m0 0h4M4 4l5 5m7-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m7 5v-4m0 0h-4m4 0l-5-5"></path>
                </svg>
            </button>

            <!-- Record Button -->
            <button id="record-btn" onclick="startRecording()" class="p-3 bg-red-600 text-white rounded-full shadow-lg hover:bg-red-700 transition duration-200 flex items-center space-x-1" title="Start Recording">
                <svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
                    <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clip-rule="evenodd"></path>
                </svg>
                <span id="record-text" class="font-semibold text-sm">Record (5 min)</span>
            </button>
        </div>
    </div>
    
    <p class="mt-2 text-sm text-red-600 italic text-center max-w-xs">
        (Note: Fullscreen and Recording features may be restricted by this editor environment.)
    </p>

    <script>
        // --- Configuration Constants ---
        // ðŸ›‘ CRITICAL FIX: You MUST replace 'YOUR_PEXELS_API_KEY' with a valid key from Pexels (or the fetch will fail).
        const API_KEY = "YOUR_PEXELS_API_KEY"; 
        const API_BASE_URL = "https://api.pexels.com/v1/search";
        const CACHE_KEY_PREFIX = "pexels_photo_cache_";
        const HISTORY_KEY = "pexels_slideshow_history";
        const CACHE_DURATION_MS = 3600000; // 1 hour
        
        let PAN_DURATION_MS = 4000; // 4 seconds (User controlled)
        const TRANSITION_DURATION_MS = 1000; // 1 second cross-fade

        // --- DOM Elements ---
        const form = document.getElementById('fetch-form');
        const categorySelect = document.getElementById('category');
        const perPageInput = document.getElementById('per_page');
        const panDurationInput = document.getElementById('pan-duration');
        const durationDisplay = document.getElementById('duration-display');
        const canvasContainer = document.getElementById('canvas-container');
        const canvas = document.getElementById('photo-canvas');
        const ctx = canvas.getContext('2d');
        const statusMessage = document.getElementById('status-message');
        const historyList = document.getElementById('history-list');
        const recordBtn = document.getElementById('record-btn');
        const recordText = document.getElementById('record-text');
        const recordDurationMinInput = document.getElementById('record-duration-min');

        // --- Slideshow/Animation State ---
        let photoUrls = [];
        let currentIndex = 0;
        let slideshowInterval = null;
        let animationFrameId = null;
        let currentImage = null; // Image object being displayed
        let nextImage = null;    // Image object that is fading in
        let panStartTime = 0;
        let activeTab = 'fetch';
        let originalCanvasSize = { width: 0, height: 0 };

        // --- Video Recording State ---
        let mediaRecorder = null;
        let recordedChunks = [];
        const VIDEO_RESOLUTION = { width: 1920, height: 1080 };
        
        // --- Helper to update duration display ---
        function updateDurationDisplay(value) {
            PAN_DURATION_MS = parseInt(value, 10);
            durationDisplay.textContent = (PAN_DURATION_MS / 1000).toFixed(1);
            if (slideshowInterval) {
                 // Restart the slideshow with the new interval duration
                 startSlideshow(categorySelect.value);
            }
        }
        
        function updateRecordDurationDisplay() {
            const duration = parseInt(recordDurationMinInput.value) || 5;
            recordText.textContent = `Record (${duration} min)`;
        }

        updateDurationDisplay(panDurationInput.value); // Set initial pan duration
        updateRecordDurationDisplay(); // Set initial record duration

        // --- Fullscreen and Canvas Setup ---

        /**
         * Toggles the canvas container into or out of fullscreen mode.
         */
        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                // Enter fullscreen mode
                canvasContainer.requestFullscreen().catch(err => {
                    if (err.name === 'SecurityError' || (err.message && err.message.includes('permissions policy'))) {
                        displayStatus("Fullscreen failed: The hosting environment blocks this feature. Try running the application in a separate browser tab.", 'error');
                    } else {
                        displayStatus(`Error attempting to enable full-screen mode: ${err.message}`, 'error');
                    }
                });
            } else {
                // Exit fullscreen mode
                document.exitFullscreen();
            }
        }
        
        /**
         * Handles resizing when the screen size or fullscreen state changes.
         */
        function resizeCanvas() {
            // Save current responsive size
            originalCanvasSize.width = canvasContainer.clientWidth;
            originalCanvasSize.height = canvasContainer.clientHeight;
            
            // Apply responsive size unless recording
            if (!mediaRecorder) {
                canvas.width = originalCanvasSize.width;
                canvas.height = originalCanvasSize.height;
            }

            if (currentImage) {
                // Re-calculate pan points and restart animation to adapt to new size
                startImageAnimation(currentImage, photoUrls[currentIndex], nextImage); 
            }
        }

        // --- Animation and Transition Logic ---

        function calculatePanPoints(img) {
            const panFactor = 1.15;
            const canvasWidth = canvas.width;
            const canvasHeight = canvas.height;
            const drawW = canvasWidth * panFactor;
            const drawH = canvasHeight * panFactor;
            const sourceScale = Math.min(img.width / drawW, img.height / drawH);
            const sourceW = drawW * sourceScale;
            const sourceH = drawH * sourceScale;
            const maxX = img.width - sourceW;
            const maxY = img.height - sourceH;
            
            const startX = Math.random() * maxX;
            const startY = Math.random() * maxY;
            let endX = Math.random() * maxX;
            let endY = Math.random() * maxY;

            // Ensure a decent amount of movement
            if (Math.abs(startX - endX) < maxX * 0.1) endX = maxX - startX; 
            if (Math.abs(startY - endY) < maxY * 0.1) endY = maxY - startY; 
            
            endX = Math.min(maxX, Math.max(0, endX));
            endY = Math.min(maxY, Math.max(0, endY));

            return { 
                destX: 0, destY: 0, destW: canvasWidth, destH: canvasHeight,
                sX: startX, sY: startY, sW: sourceW, sH: sourceH,
                eX: endX, eY: endY, eW: sourceW, eH: sourceH
            };
        }

        function startImageAnimation(img1, url1, img2, url2) {
            stopAnimation();

            img1.pan = calculatePanPoints(img1);
            currentImage = img1;
            
            if (img2) {
                img2.pan = calculatePanPoints(img2);
                nextImage = img2;
            } else {
                nextImage = null;
            }

            panStartTime = 0; 
            animationFrameId = requestAnimationFrame(animatePan);
        }

        function animatePan(timestamp) {
            if (!currentImage) return;

            if (!panStartTime) panStartTime = timestamp;
            const elapsed = timestamp - panStartTime;
            
            // Total duration for the pan effect
            const totalDuration = PAN_DURATION_MS;

            // Pan progress for the current image (0 to 1)
            const panProgress = Math.min(elapsed / (totalDuration - TRANSITION_DURATION_MS), 1);
            
            // Transition progress for the next image (0 to 1)
            const transitionProgress = Math.min(Math.max(0, elapsed - (totalDuration - TRANSITION_DURATION_MS)) / TRANSITION_DURATION_MS, 1);

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 1. Draw Previous/Current Image (Panning)
            if (currentImage.pan) {
                const { destX, destY, destW, destH, sX, sY, sW, sH, eX, eY } = currentImage.pan;
                const currentSrcX = sX + (eX - sX) * panProgress;
                const currentSrcY = sY + (eY - sY) * panProgress;
                
                // Fade out current image
                ctx.globalAlpha = 1 - transitionProgress; 
                ctx.drawImage(currentImage, currentSrcX, currentSrcY, sW, sH, destX, destY, destW, destH);
                ctx.globalAlpha = 1; // Reset
            }

            // 2. Draw Next Image (Fading In and Panning)
            if (nextImage && nextImage.pan) {
                const { destX, destY, destW, destH, sX, sY, sW, sH, eX, eY } = nextImage.pan;
                const currentSrcX = sX + (eX - sX) * panProgress;
                const currentSrcY = sY + (eY - sY) * panProgress;

                // Fade in next image
                ctx.globalAlpha = transitionProgress;
                ctx.drawImage(nextImage, currentSrcX, currentSrcY, sW, sH, destX, destY, destW, destH);
                ctx.globalAlpha = 1; // Reset
            }


            if (elapsed < totalDuration) {
                animationFrameId = requestAnimationFrame(animatePan);
            } else {
                // Transition finished, set next image as current and stop old pan
                currentImage = nextImage;
                nextImage = null;
                panStartTime = 0; 
                
                // The slideshow interval will trigger the next image load
            }
        }

        function loadImage(url, callback) {
            const img = new Image();
            // Critical for canvas.captureStream to avoid CORS issues
            img.crossOrigin = 'Anonymous'; 

            img.onload = () => {
                callback(img);
            };

            img.onerror = () => {
                console.error(`Failed to load image: ${url}`);
                callback(null);
            };

            img.src = url;
        }
        
        function loadNextImage() {
            if (photoUrls.length === 0) return;

            const nextIndex = (currentIndex + 1) % photoUrls.length;
            const currentUrl = photoUrls[currentIndex];
            const nextUrl = photoUrls[nextIndex];

            // 1. Load current image
            loadImage(currentUrl, (img1) => {
                if (!img1) {
                    displayStatus("Failed to load an image. Skipping.", 'error');
                    currentIndex = nextIndex;
                    return;
                }

                // 2. Load next image
                loadImage(nextUrl, (img2) => {
                    // Start the pan animation with the current image and the next image for cross-fade
                    startImageAnimation(img1, currentUrl, img2, nextUrl);
                    currentIndex = nextIndex;
                });
            });
        }

        function stopAnimation() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            panStartTime = 0;
        }

        function stopSlideshow() {
             if (slideshowInterval) {
                clearInterval(slideshowInterval);
                slideshowInterval = null;
            }
            stopAnimation();
        }

        function startSlideshow(category) {
            stopSlideshow();

            if (photoUrls.length === 0) {
                displayStatus(`No images found for category: ${category}. Check your API Key.`, 'error');
                return;
            }
            
            currentIndex = photoUrls.length - 1; // Set back 1 so loadNextImage loads index 0 first
            
            // Load first two images to kick off the loop
            loadNextImage();

            // Set the interval to trigger the next image load right after the pan duration finishes
            slideshowInterval = setInterval(() => {
                loadNextImage();
            }, PAN_DURATION_MS); 
            
            displayStatus(`Slideshow started with ${photoUrls.length} images for category: ${category} (${(PAN_DURATION_MS / 1000).toFixed(1)}s Pan/Transition)`, 'success');
        }

        // --- Video Recording Logic ---

        function startRecording() {
            if (mediaRecorder) {
                displayStatus("Recording already in progress. Click Stop Recording.", 'info');
                return;
            }
            
            if (photoUrls.length === 0) {
                 displayStatus("Please fetch images and start the slideshow before recording.", 'error');
                 return;
            }
            
            const recordDurationMinutes = parseInt(recordDurationMinInput.value) || 5;
            if (recordDurationMinutes < 1 || recordDurationMinutes > 10) {
                displayStatus("Please set a recording duration between 1 and 10 minutes.", 'error');
                return;
            }
            const recordDurationMS = recordDurationMinutes * 60 * 1000;

            // 1. Set canvas to target resolution (1920x1080) for high quality video output
            canvas.width = VIDEO_RESOLUTION.width;
            canvas.height = VIDEO_RESOLUTION.height;
            resizeCanvas(); 

            // 2. Setup MediaRecorder
            const stream = canvas.captureStream(30); // 30 FPS
            
            recordedChunks = [];
            
            // Use WebM format with H.264 codec for compatibility
            const options = { mimeType: 'video/webm; codecs=vp8' };

            try {
                mediaRecorder = new MediaRecorder(stream, options);
            } catch (e) {
                displayStatus(`Recording failed: MediaRecorder setup error: ${e.message}`, 'error');
                canvas.width = originalCanvasSize.width; // Restore original size
                canvas.height = originalCanvasSize.height;
                resizeCanvas();
                return;
            }

            mediaRecorder.ondataavailable = (event) => {
                if (event.data.size > 0) {
                    recordedChunks.push(event.data);
                }
            };

            mediaRecorder.onstop = downloadVideo;

            mediaRecorder.start();

            // Update UI for recording state
            recordBtn.onclick = stopRecording;
            recordBtn.classList.remove('bg-red-600', 'hover:bg-red-700');
            recordBtn.classList.add('bg-gray-600', 'hover:bg-gray-700');
            recordText.textContent = 'STOP RECORDING';

            displayStatus(`Recording started at 1920x1080 for ${recordDurationMinutes} minutes...`, 'info');
            
            // Automatically stop after user-defined duration
            setTimeout(() => {
                if (mediaRecorder && mediaRecorder.state === 'recording') {
                    stopRecording();
                }
            }, recordDurationMS);
        }

        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
                
                // Restore UI for non-recording state
                recordBtn.onclick = startRecording;
                recordBtn.classList.remove('bg-gray-600', 'hover:bg-gray-700');
                recordBtn.classList.add('bg-red-600', 'hover:bg-red-700');
                updateRecordDurationDisplay(); // Restore text

                // Restore canvas resolution to responsive size
                canvas.width = originalCanvasSize.width;
                canvas.height = originalCanvasSize.height;
                resizeCanvas();
            }
        }

        function downloadVideo() {
            if (recordedChunks.length === 0) {
                displayStatus("Recording finished, but no data was captured. Ensure the slideshow was running during recording.", 'error');
                mediaRecorder = null;
                return;
            }
            
            const blob = new Blob(recordedChunks, { type: 'video/webm' });
            const url = URL.createObjectURL(blob);
            
            // Create a temporary download link
            const a = document.createElement('a');
            a.style.display = 'none';
            a.href = url;
            a.download = `slideshow_${new Date().toISOString()}.webm`;
            
            document.body.appendChild(a);
            a.click();
            
            // Cleanup
            window.URL.revokeObjectURL(url);
            document.body.removeChild(a);

            displayStatus(`Video downloaded! Resolution: 1920x1080. Check your downloads folder.`, 'success');
            mediaRecorder = null;
        }

        // --- History and Fetch Logic ---

        function switchTab(tabId) {
            document.getElementById('tab-fetch').classList.add('hidden');
            document.getElementById('tab-history').classList.add('hidden');
            document.getElementById('tab-fetch-btn').classList.remove('active');
            document.getElementById('tab-history-btn').classList.remove('active');

            document.getElementById(`tab-${tabId}`).classList.remove('hidden');
            document.getElementById(`tab-${tabId}-btn`).classList.add('active');
            activeTab = tabId;

            if (tabId === 'history') { loadHistory(); }
        }

        function displayStatus(message, type = 'loading') {
            statusMessage.textContent = message;
            statusMessage.className = 'mt-4 p-4 rounded-lg text-lg font-medium w-full max-w-4xl text-center transition-colors';
            
            if (type === 'error') {
                statusMessage.classList.add('bg-red-200', 'text-red-800');
            } else if (type === 'success') {
                statusMessage.classList.add('bg-green-200', 'text-green-800');
            } else if (type === 'info') {
                statusMessage.classList.add('bg-yellow-200', 'text-yellow-800');
            } else {
                statusMessage.classList.add('bg-blue-200', 'text-blue-800');
            }
        }
        
        function saveToHistory(query, perPage) { 
            try {
                const existingHistory = JSON.parse(localStorage.getItem(HISTORY_KEY) || '[]');
                const timestamp = Date.now();
                const cacheId = query + '_' + perPage;

                let updated = false;
                for (let i = 0; i < existingHistory.length; i++) {
                    if (existingHistory[i].cacheId === cacheId) {
                        existingHistory[i].timestamp = timestamp;
                        existingHistory[i].label = `${query.charAt(0).toUpperCase() + query.slice(1)} (${perPage} photos) - ${new Date(timestamp).toLocaleTimeString()}`;
                        const item = existingHistory.splice(i, 1)[0];
                        existingHistory.unshift(item);
                        updated = true;
                        break;
                    }
                }

                if (!updated) {
                    const newEntry = {
                        timestamp: timestamp,
                        cacheId: cacheId,
                        query: query,
                        perPage: perPage,
                        label: `${query.charAt(0).toUpperCase() + query.slice(1)} (${perPage} photos) - ${new Date(timestamp).toLocaleTimeString()}`,
                    };
                    existingHistory.unshift(newEntry);
                }

                localStorage.setItem(HISTORY_KEY, JSON.stringify(existingHistory.slice(0, 20)));

            } catch (error) {
                console.error("Failed to save history:", error);
            }
        }
        
        function loadHistory() {
            historyList.innerHTML = '';
            try {
                const history = JSON.parse(localStorage.getItem(HISTORY_KEY) || '[]');

                if (history.length === 0) {
                    historyList.innerHTML = '<li class="text-gray-500 italic p-2">No previous searches found.</li>';
                    return;
                }

                history.forEach(item => {
                    const li = document.createElement('li');
                    li.className = 'history-item p-3 border-b border-gray-100 last:border-b-0 flex justify-between items-center';
                    li.innerHTML = `
                        <span class="text-gray-800">${item.label}</span>
                        <span class="text-xs text-gray-500">${new Date(item.timestamp).toLocaleDateString()}</span>
                    `;
                    li.onclick = () => loadFromHistory(item);
                    historyList.appendChild(li);
                });

            } catch (error) {
                console.error("Failed to load history:", error);
                historyList.innerHTML = '<li class="text-red-500 p-2">Error loading history data.</li>';
            }
        }
        
        function loadFromHistory(historyItem) {
            const currentCacheKey = CACHE_KEY_PREFIX + historyItem.cacheId;
            const cachedData = localStorage.getItem(currentCacheKey);
            const now = Date.now();

            if (!cachedData) {
                displayStatus(`Error: No image cache found for '${historyItem.query}'. Please re-fetch.`, 'error');
                return;
            }

            try {
                const cache = JSON.parse(cachedData);
                if (now - cache.timestamp < CACHE_DURATION_MS) {
                    displayStatus(`Loading slideshow from cache: ${historyItem.label}.`, 'success');
                    photoUrls = cache.photos.map(p => p.src.large);
                    startSlideshow(historyItem.query);
                    switchTab('fetch');
                } else {
                    displayStatus(`Cache for '${historyItem.query}' has expired. Please re-fetch from the 'Fetch New Data' tab.`, 'info');
                    localStorage.removeItem(currentCacheKey);
                }
            } catch (e) {
                console.error("Error processing history cache:", e);
                displayStatus("Error reading cached images. Please try fetching new data.", 'error');
            }
        }
        
        async function fetchPexelsImage(query, perPage, checkOnly = false) {
             const currentCacheKey = CACHE_KEY_PREFIX + query + '_' + perPage;
            const PEXELS_SEARCH_URL = `${API_BASE_URL}?query=${encodeURIComponent(query)}&per_page=${perPage}&orientation=landscape`;
            
            displayStatus(`Checking cache for '${query}' (${perPage} images)...`);
            
            const cachedData = localStorage.getItem(currentCacheKey);
            const now = Date.now();

            if (cachedData) {
                try {
                    const cache = JSON.parse(cachedData);
                    if (now - cache.timestamp < CACHE_DURATION_MS) {
                        displayStatus(`Serving data from local cache for '${query}'.`, 'success');
                        photoUrls = cache.photos.map(p => p.src.large);
                        startSlideshow(query);
                        saveToHistory(query, perPage); 
                        return;
                    } else {
                        displayStatus(`Local cache for '${query}' expired. Ready to fetch new data.`);
                        localStorage.removeItem(currentCacheKey);
                    }
                } catch (e) {
                    console.error("Error parsing cached data:", e);
                    localStorage.removeItem(currentCacheKey);
                }
            }
            
            if (checkOnly) {
                if (API_KEY === "YOUR_PEXELS_API_KEY") {
                    displayStatus("CRITICAL: Please enter your Pexels API Key in the script source code to load images.", 'error');
                } else {
                    displayStatus("No valid cache found. Ready for a new search.", 'info');
                }
                return;
            }

            displayStatus(`Fetching ${perPage} '${query}' images from Pexels API...`);
            try {
                if (API_KEY === "YOUR_PEXELS_API_KEY") { 
                    throw new Error("Pexels API Key is missing. Please replace 'YOUR_PEXELS_API_KEY' in the script."); 
                }

                const response = await fetch(PEXELS_SEARCH_URL, {
                    method: 'GET',
                    headers: { 'Authorization': API_KEY, 'Content-Type': 'application/json' }
                });

                if (!response.ok) {
                    if (response.status === 403 || response.status === 401) {
                         throw new Error(`Authentication Error (Status ${response.status}). Please ensure your Pexels API Key is valid and correctly placed in the script.`);
                    }
                    throw new Error(`Failed to fetch data: HTTP status ${response.status} (${response.statusText})`);
                }

                const data = await response.json();
                
                if (data.photos && data.photos.length > 0) {
                    const cachePayload = { timestamp: Date.now(), photos: data.photos };
                    localStorage.setItem(currentCacheKey, JSON.stringify(cachePayload));
                    
                    photoUrls = data.photos.map(p => p.src.large);
                    saveToHistory(query, perPage); 
                    startSlideshow(query);
                } else {
                     throw new Error("API call was successful but returned no photos for this search query.");
                }

            } catch (error) {
                console.error("Fetch Error:", error);
                displayStatus(`Error: ${error.message}`, 'error');
                stopSlideshow();
            }
        }

        // --- Event Listeners and Initialization ---
        form.addEventListener('submit', function(event) {
            event.preventDefault();
            
            const query = categorySelect.value;
            const perPage = Math.min(100, Math.max(1, parseInt(perPageInput.value) || 15)); 
            perPageInput.value = perPage;

            fetchPexelsImage(query, perPage, false);
        });

        // Listen for browser fullscreen changes to ensure canvas size is updated correctly
        document.addEventListener('fullscreenchange', resizeCanvas); 
        document.addEventListener('webkitfullscreenchange', resizeCanvas);
        document.addEventListener('mozfullscreenchange', resizeCanvas);
        document.addEventListener('MSFullscreenChange', resizeCanvas);
        window.addEventListener('resize', resizeCanvas);

        window.onload = () => {
            // Initial canvas setup
            resizeCanvas(); 
            
            // Set initial tab state
            switchTab('fetch');

            // Automatically attempt to load cache for the default values (Nature, 15) on startup
            const defaultCategory = categorySelect.value;
            const defaultPerPage = parseInt(perPageInput.value);
            
            fetchPexelsImage(defaultCategory, defaultPerPage, true);
        };
        // End of code

    </script>
</body>
</html>