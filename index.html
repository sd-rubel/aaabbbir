<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic Pexels Slideshow - Fullscreen</title>
    <!-- Load Tailwind CSS for modern, responsive styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for the canvas container to maintain 16:9 aspect ratio */
        #canvas-container {
            width: 100%;
            max-width: 900px; 
            margin: 0 auto;
            /* The padding-top trick maintains the aspect ratio: (9 / 16) * 100 = 56.25% */
            padding-top: 56.25%; 
            position: relative;
            background-color: #1f2937; /* Dark background */
            border-radius: 0.75rem;
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.2);
            overflow: hidden;
            transition: max-width 0.3s, padding-top 0.3s; /* Smooth transition for responsiveness */
        }

        /* Fullscreen styles for the container */
        #canvas-container:fullscreen {
            max-width: none; /* Remove max width constraint */
            width: 100%;
            height: 100vh; /* Fill viewport height */
            padding-top: 0; /* Disable aspect ratio padding trick */
            border-radius: 0;
            box-shadow: none;
        }

        /* Fullscreen styles for the canvas element itself */
        #photo-canvas:fullscreen {
            width: 100%;
            height: 100%;
            position: absolute;
        }
        
        #photo-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: block;
        }

        /* Style for the active tab */
        .tab-button.active {
            border-bottom: 3px solid #3b82f6; /* Blue border */
            color: #1f2937;
            font-weight: 600;
        }
        
        /* Style for history items */
        .history-item {
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .history-item:hover {
            background-color: #f3f4f6;
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen p-4 flex flex-col items-center font-sans">

    <div class="w-full max-w-4xl text-center mb-6">
        <h1 class="text-3xl font-extrabold text-gray-800 mb-2">Pexels Slideshow</h1>
        <p class="text-gray-600">Pan/Zoom effect every 4 seconds.</p>
    </div>

    <!-- Tabs Container -->
    <div class="w-full max-w-md bg-white rounded-t-xl shadow-lg">
        <div class="flex border-b border-gray-200">
            <button id="tab-fetch-btn" onclick="switchTab('fetch')" class="tab-button active flex-1 py-3 text-gray-500 hover:text-gray-800 transition duration-150">
                Fetch New Data
            </button>
            <button id="tab-history-btn" onclick="switchTab('history')" class="tab-button flex-1 py-3 text-gray-500 hover:text-gray-800 transition duration-150">
                Load from History
            </button>
        </div>

        <!-- Tab Content: Fetch New Data -->
        <div id="tab-fetch" class="p-6">
            <form id="fetch-form" class="flex flex-col space-y-4">
                <div class="flex flex-col sm:flex-row sm:space-x-4 space-y-4 sm:space-y-0">
                    <!-- Category Dropdown -->
                    <div class="flex-1">
                        <label for="category" class="block text-sm font-medium text-gray-700 mb-1">Image Category</label>
                        <select id="category" name="category" class="w-full p-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500">
                            <option value="nature">Nature</option>
                            <option value="islamic">Muslim and Islamic Related</option>
                            <option value="flower">Flowers</option>
                            <option value="city">City / Architecture</option>
                            <option value="technology">Technology</option>
                            <option value="travel">Travel</option>
                            <option value="food">Food</option>
                            <option value="abstract">Abstract</option>
                        </select>
                    </div>
                    
                    <!-- Number of Images Input -->
                    <div class="flex-1">
                        <label for="per_page" class="block text-sm font-medium text-gray-700 mb-1">Number of Images (Max 100)</label>
                        <input type="number" id="per_page" name="per_page" min="1" max="100" value="15" required class="w-full p-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500">
                    </div>
                </div>

                <!-- Submit Button -->
                <button type="submit" class="w-full py-2 px-4 bg-blue-600 text-white font-semibold rounded-lg shadow-md hover:bg-blue-700 transition duration-200">
                    Fetch & Start Slideshow
                </button>
            </form>
        </div>

        <!-- Tab Content: History -->
        <div id="tab-history" class="p-6 hidden">
            <h3 class="text-xl font-semibold text-gray-800 mb-4 border-b pb-2">Cached Searches</h3>
            <ul id="history-list" class="space-y-2 max-h-64 overflow-y-auto">
                <li class="text-gray-500 italic">No history items found.</li>
            </ul>
        </div>
    </div>

    <!-- Status/Error Message Area -->
    <div id="status-message" class="mt-4 p-4 rounded-lg text-lg font-medium w-full max-w-4xl text-center">
        <!-- Messages will be inserted here -->
    </div>

    <!-- Canvas Container (16:9 aspect ratio maintained by CSS) -->
    <div id="canvas-container" class="mb-4">
        <canvas id="photo-canvas">
            Your browser does not support the HTML canvas tag.
        </canvas>
    </div>

    <!-- Fullscreen Toggle Button and Warning -->
    <div class="flex flex-col items-center w-full max-w-lg mb-8">
        <button id="fullscreen-btn" onclick="toggleFullscreen()" class="py-2 px-4 bg-gray-500 text-white font-semibold rounded-lg shadow-md hover:bg-gray-600 transition duration-200">
            Toggle Fullscreen
        </button>
        <p class="mt-2 text-sm text-red-600 italic text-center max-w-xs">
            (Note: Fullscreen mode may be blocked by this editor environment for security reasons.)
        </p>
    </div>


    <script>
        // --- Configuration Constants ---
        const API_KEY = "B8Cmh6x8Km7BzVDsyCS3sHbHiCWvrD42E5D7PeErJqFROcrp05fummN3"; 
        const API_BASE_URL = "https://api.pexels.com/v1/search";
        const CACHE_KEY_PREFIX = "pexels_photo_cache_";
        const HISTORY_KEY = "pexels_slideshow_history";
        const CACHE_DURATION_MS = 3600000; // 1 hour
        const PAN_DURATION_MS = 4000; // 4 seconds duration for pan effect

        // --- DOM Elements ---
        const form = document.getElementById('fetch-form');
        const categorySelect = document.getElementById('category');
        const perPageInput = document.getElementById('per_page');
        const canvasContainer = document.getElementById('canvas-container'); // Use container for fullscreen
        const canvas = document.getElementById('photo-canvas');
        const ctx = canvas.getContext('2d');
        const statusMessage = document.getElementById('status-message');
        const historyList = document.getElementById('history-list');

        // --- Slideshow/Animation State ---
        let photoUrls = [];
        let currentIndex = 0;
        let slideshowInterval = null;
        let animationFrameId = null;
        let currentImage = null;
        let panStartTime = 0;
        let activeTab = 'fetch';

        /**
         * Toggles the canvas container into or out of fullscreen mode.
         * Includes specific error handling for permissions policy errors.
         */
        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                // Enter fullscreen mode on the container
                canvasContainer.requestFullscreen().catch(err => {
                    // Check specifically for the common permission error
                    if (err.name === 'SecurityError' || err.message.includes('permissions policy')) {
                        displayStatus("Fullscreen failed: The hosting environment (like this editor) often blocks this feature for security. Try running the application in a separate browser tab if available.", 'error');
                    } else {
                        displayStatus(`Error attempting to enable full-screen mode: ${err.message}`, 'error');
                    }
                });
            } else {
                // Exit fullscreen mode
                document.exitFullscreen();
            }
        }
        
        /**
         * Handles resizing when the screen size or fullscreen state changes.
         */
        function resizeCanvas() {
            // Use the container's current dimensions 
            canvas.width = canvasContainer.clientWidth;
            canvas.height = canvasContainer.clientHeight;

            if (currentImage) {
                // Re-calculate pan points and restart animation to adapt to new size
                startImageAnimation(currentImage, photoUrls[currentIndex]); 
            }
        }

        // --- Rest of the Slideshow and History Logic (Maintained) ---

        /**
         * Switches the visible tab content.
         */
        function switchTab(tabId) {
            document.getElementById('tab-fetch').classList.add('hidden');
            document.getElementById('tab-history').classList.add('hidden');
            document.getElementById('tab-fetch-btn').classList.remove('active');
            document.getElementById('tab-history-btn').classList.remove('active');

            document.getElementById(`tab-${tabId}`).classList.remove('hidden');
            document.getElementById(`tab-${tabId}-btn`).classList.add('active');
            activeTab = tabId;

            if (tabId === 'history') {
                loadHistory();
            }
        }

        /**
         * Utility function to display messages to the user.
         */
        function displayStatus(message, type = 'loading') {
            statusMessage.textContent = message;
            statusMessage.className = 'mt-4 p-4 rounded-lg text-lg font-medium w-full max-w-4xl text-center transition-colors';
            
            if (type === 'error') {
                statusMessage.classList.add('bg-red-200', 'text-red-800');
            } else if (type === 'success') {
                statusMessage.classList.add('bg-green-200', 'text-green-800');
            } else if (type === 'info') {
                statusMessage.classList.add('bg-yellow-200', 'text-yellow-800');
            } else {
                statusMessage.classList.add('bg-blue-200', 'text-blue-800');
            }
        }
        
        function calculatePanPoints(img) {
            const panFactor = 1.15; 
            const canvasWidth = canvas.width;
            const canvasHeight = canvas.height;
            const drawW = canvasWidth * panFactor;
            const drawH = canvasHeight * panFactor;
            const sourceScale = Math.min(img.width / drawW, img.height / drawH);
            const sourceW = drawW * sourceScale;
            const sourceH = drawH * sourceScale;
            const maxX = img.width - sourceW;
            const maxY = img.height - sourceH;
            
            const startX = Math.random() * maxX;
            const startY = Math.random() * maxY;
            let endX = Math.random() * maxX;
            let endY = Math.random() * maxY;

            if (Math.abs(startX - endX) < maxX * 0.1) endX = maxX - startX; 
            if (Math.abs(startY - endY) < maxY * 0.1) endY = maxY - startY; 
            
            endX = Math.min(maxX, Math.max(0, endX));
            endY = Math.min(maxY, Math.max(0, endY));

            return { 
                destX: 0, destY: 0, destW: canvasWidth, destH: canvasHeight,
                sX: startX, sY: startY, sW: sourceW, sH: sourceH,
                eX: endX, eY: endY, eW: sourceW, eH: sourceH
            };
        }

        function animatePan(timestamp) {
            if (!currentImage || !currentImage.pan) return;
            
            if (!panStartTime) panStartTime = timestamp;
            const elapsed = timestamp - panStartTime;
            const progress = Math.min(elapsed / PAN_DURATION_MS, 1);

            const { destX, destY, destW, destH, sX, sY, sW, sH, eX, eY } = currentImage.pan;
            const currentSrcX = sX + (eX - sX) * progress;
            const currentSrcY = sY + (eY - sY) * progress;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            ctx.drawImage(currentImage, currentSrcX, currentSrcY, sW, sH, destX, destY, destW, destH);

            if (progress < 1) {
                animationFrameId = requestAnimationFrame(animatePan);
            } else {
                panStartTime = 0; 
                animationFrameId = null;
            }
        }

        function startImageAnimation(img, url) {
            stopAnimation();
            img.pan = calculatePanPoints(img);
            currentImage = img;
            panStartTime = 0; 
            animationFrameId = requestAnimationFrame(animatePan);
        }
        
        function loadImageAndDraw(url) {
            const img = new Image();
            img.crossOrigin = 'Anonymous';

            img.onload = () => {
                startImageAnimation(img, url);
            };

            img.onerror = () => {
                console.error(`Failed to load image: ${url}`);
                ctx.fillStyle = '#ef4444';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.font = '20px sans-serif';
                ctx.fillStyle = '#ffffff';
                ctx.textAlign = 'center';
                ctx.fillText('Image Load Failed', canvas.width / 2, canvas.height / 2);
                stopAnimation(); 
            };

            img.src = url;
        }

        function stopAnimation() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            currentImage = null;
            panStartTime = 0;
        }

        function stopSlideshow() {
             if (slideshowInterval) {
                clearInterval(slideshowInterval);
                slideshowInterval = null;
            }
            stopAnimation();
        }

        function startSlideshow(category) {
            stopSlideshow();

            if (photoUrls.length === 0) {
                displayStatus(`No images found for category: ${category}.`, 'error');
                return;
            }
            
            currentIndex = 0;
            loadImageAndDraw(photoUrls[currentIndex]);

            slideshowInterval = setInterval(() => {
                currentIndex = (currentIndex + 1) % photoUrls.length;
                loadImageAndDraw(photoUrls[currentIndex]);
            }, PAN_DURATION_MS); 
            
            displayStatus(`Slideshow started with ${photoUrls.length} images for category: ${category} (4s Pan/Transition)`, 'success');
        }

        function saveToHistory(query, perPage) {
            try {
                const existingHistory = JSON.parse(localStorage.getItem(HISTORY_KEY) || '[]');
                const timestamp = Date.now();
                const cacheId = query + '_' + perPage;

                let updated = false;
                for (let i = 0; i < existingHistory.length; i++) {
                    if (existingHistory[i].cacheId === cacheId) {
                        existingHistory[i].timestamp = timestamp;
                        existingHistory[i].label = `${query.charAt(0).toUpperCase() + query.slice(1)} (${perPage} photos) - ${new Date(timestamp).toLocaleTimeString()}`;
                        // Move the updated item to the front
                        const item = existingHistory.splice(i, 1)[0];
                        existingHistory.unshift(item);
                        updated = true;
                        break;
                    }
                }

                if (!updated) {
                    const newEntry = {
                        timestamp: timestamp,
                        cacheId: cacheId,
                        query: query,
                        perPage: perPage,
                        label: `${query.charAt(0).toUpperCase() + query.slice(1)} (${perPage} photos) - ${new Date(timestamp).toLocaleTimeString()}`,
                    };
                    existingHistory.unshift(newEntry);
                }

                localStorage.setItem(HISTORY_KEY, JSON.stringify(existingHistory.slice(0, 20)));

            } catch (error) {
                console.error("Failed to save history:", error);
            }
        }

        function loadHistory() {
            historyList.innerHTML = '';
            try {
                const history = JSON.parse(localStorage.getItem(HISTORY_KEY) || '[]');

                if (history.length === 0) {
                    historyList.innerHTML = '<li class="text-gray-500 italic p-2">No previous searches found.</li>';
                    return;
                }

                history.forEach(item => {
                    const li = document.createElement('li');
                    li.className = 'history-item p-3 border-b border-gray-100 last:border-b-0 flex justify-between items-center';
                    li.innerHTML = `
                        <span class="text-gray-800">${item.label}</span>
                        <span class="text-xs text-gray-500">${new Date(item.timestamp).toLocaleDateString()}</span>
                    `;
                    li.onclick = () => loadFromHistory(item);
                    historyList.appendChild(li);
                });

            } catch (error) {
                console.error("Failed to load history:", error);
                historyList.innerHTML = '<li class="text-red-500 p-2">Error loading history data.</li>';
            }
        }

        function loadFromHistory(historyItem) {
            const currentCacheKey = CACHE_KEY_PREFIX + historyItem.cacheId;
            const cachedData = localStorage.getItem(currentCacheKey);
            const now = Date.now();

            if (!cachedData) {
                displayStatus(`Error: No image cache found for '${historyItem.query}'. Please re-fetch.`, 'error');
                return;
            }

            try {
                const cache = JSON.parse(cachedData);
                if (now - cache.timestamp < CACHE_DURATION_MS) {
                    displayStatus(`Loading slideshow from cache: ${historyItem.label}.`, 'success');
                    photoUrls = cache.photos.map(p => p.src.large);
                    startSlideshow(historyItem.query);
                    switchTab('fetch');
                } else {
                    displayStatus(`Cache for '${historyItem.query}' has expired. Please re-fetch from the 'Fetch New Data' tab.`, 'info');
                    localStorage.removeItem(currentCacheKey);
                }
            } catch (e) {
                console.error("Error processing history cache:", e);
                displayStatus("Error reading cached images. Please try fetching new data.", 'error');
            }
        }

        async function fetchPexelsImage(query, perPage, checkOnly = false) {
            const currentCacheKey = CACHE_KEY_PREFIX + query + '_' + perPage;
            const PEXELS_SEARCH_URL = `${API_BASE_URL}?query=${encodeURIComponent(query)}&per_page=${perPage}&orientation=landscape`;
            
            displayStatus(`Checking cache for '${query}' (${perPage} images)...`);
            
            const cachedData = localStorage.getItem(currentCacheKey);
            const now = Date.now();

            if (cachedData) {
                try {
                    const cache = JSON.parse(cachedData);
                    if (now - cache.timestamp < CACHE_DURATION_MS) {
                        displayStatus(`Serving data from local cache for '${query}'.`, 'success');
                        photoUrls = cache.photos.map(p => p.src.large);
                        startSlideshow(query);
                        saveToHistory(query, perPage); 
                        return;
                    } else {
                        displayStatus(`Local cache for '${query}' expired. Ready to fetch new data.`);
                        localStorage.removeItem(currentCacheKey);
                    }
                } catch (e) {
                    console.error("Error parsing cached data:", e);
                    localStorage.removeItem(currentCacheKey);
                }
            }
            
            if (checkOnly) {
                displayStatus("No valid cache found. Ready for a new search.", 'info');
                return;
            }

            displayStatus(`Fetching ${perPage} '${query}' images from Pexels API...`);
            try {
                if (!API_KEY) { throw new Error("Pexels API Key is missing."); }

                const response = await fetch(PEXELS_SEARCH_URL, {
                    method: 'GET',
                    headers: { 'Authorization': API_KEY, 'Content-Type': 'application/json' }
                });

                if (!response.ok) {
                    throw new Error(`Failed to fetch data: HTTP status ${response.status} (${response.statusText})`);
                }

                const data = await response.json();
                
                if (data.photos && data.photos.length > 0) {
                    const cachePayload = { timestamp: Date.now(), photos: data.photos };
                    localStorage.setItem(currentCacheKey, JSON.stringify(cachePayload));
                    
                    photoUrls = data.photos.map(p => p.src.large);
                    saveToHistory(query, perPage); 
                    startSlideshow(query);
                } else {
                     throw new Error("API call was successful but returned no photos for this search query.");
                }

            } catch (error) {
                console.error("Fetch Error:", error);
                displayStatus(`Error: ${error.message}. Check your API key or try a different category/number of images.`, 'error');
                stopSlideshow();
            }
        }

        // --- Event Listeners and Initialization ---
        form.addEventListener('submit', function(event) {
            event.preventDefault();
            
            const query = categorySelect.value;
            const perPage = Math.min(100, Math.max(1, parseInt(perPageInput.value) || 15)); 
            perPageInput.value = perPage;

            fetchPexelsImage(query, perPage, false);
        });

        // Listen for browser fullscreen changes to ensure canvas size is updated correctly
        document.addEventListener('fullscreenchange', resizeCanvas); 
        document.addEventListener('webkitfullscreenchange', resizeCanvas);
        document.addEventListener('mozfullscreenchange', resizeCanvas);
        document.addEventListener('MSFullscreenChange', resizeCanvas);
        window.addEventListener('resize', resizeCanvas);

        window.onload = () => {
            // Initial canvas setup
            resizeCanvas(); 
            
            // Set initial tab state
            switchTab('fetch');

            // Automatically attempt to load cache for the default values (Nature, 15) on startup
            const defaultCategory = categorySelect.value;
            const defaultPerPage = parseInt(perPageInput.value);
            
            fetchPexelsImage(defaultCategory, defaultPerPage, true);
        };

    </script>
</body>
</html>